Dati da prendere:
Address: #Dei minatori
{
	hash,
	miningCount,
	tx_mining : [], #appare a destra,ma a sinistra non c'è nessuno
	tx_payment : [], #appare a sinistra
	tx_credit : [], #appare a destra
	totBitCoinMined,
	totDollarMined,
	currentBitCoin, #current dollar è derivato 
}

Tx:
{
	id,
	time,
	fee, #input - output
	addresses_sending : [(address, value)]
	addresses_receving : [(address, value)]
}



Pseudocodifica:
global minersAddresses = []


function startParsing():
	for blocco in blocchi:
		tx0 = new TX(blocco[0]) #di sicuro è tx_mining

		#I miner vengono creati solo per la tx0
		for address in tx0.addresses_receving:
			minersAddresses.append(new Address(tx0.address))

		#Le altre transazioni aggiungo informazioni
		for tx in tx[1->len]:
			tx_obj = new TX(tx)
			addAddressInformation(tx_obj)



#Completa le informazioni per ogni address miner già visto
function addAddressInformation(tx):
	for vout in tx['vout']:
		addresses = vout['addresses']
		for address in addresses:
			if (minersAddresses.contains(address))
				miner = getMiner(address)
				#Sta ricevend un pagamento -> non è la 0 -> è credit
				
				miner['tx_credit'].append(tx)

	#controllare i vin
	for vin in tx['vin']:
		addresses = getAddressesFromTX(vin['txid'], vin['vout'])
		for address in addresses:
			if (minersAddresses.contains(address))
				miner = getMiner(address)
				#Sta ricevend un pagamento -> non è la 0 -> è credit
				miner['tx_payment'].append(tx)




function getAddressesFromTX(txid, index):


function newTX(blocco):
	return {
		id : blocco['txid']
		#time : poi si prende
		fee : 0
		addresses_sending : []
		addresses_receving : blocco['vout']['addresses'] #per ogni vout
	}









---------------------------------------------------------------

global minersAddresses = []

function newTX(txid, time_block):
	id = txid
	time = time_block
	tx = getJSONTransactionFromID(txid)
	value_in = 0
	value_out = 0


	address_receving = []
	for vout in tx['vout']:
		for address in vout['addresses']:
			value_out =  value_out + vout['value']
			address_receving.add( (address, vout['value']) )


	address_sending = []
	for vin in tx['vin']:
		index = vin['vout']
		tx_in = getJSONTransactionFromID(vin['txid'], index)
		prec_vout = tx_in['vout'][index]
			for address in prec_vout['addresses']:
				value_in = value_in + vout['value']
				address_sending.add( (address, prec_vout['value']) )

	fee = value_in - value_out

	return {	

		id : id,
		time : time,
		output : value_out
		fee : fee,
		address_receving = address_receving,
		address_sending = address_sending

	}

function newAddress(address,tx):
	return {
		hash : address,
		miningCount : 1,
		tx_mining : [tx],
		tx_payment : [],
		tx_credit : [],
		totBitCoinMined : sum(tx['addressesValue_receving']['value']),
		totDollarMined : da calcolare,
		currentBitCoin : sum(tx['addressesValue_receving']['value'])
	}



function getJSONTransactionFromID:

	getTransaction(block, num) in main.py


function addNewPayment(minator, tx):	
	minator['tx_payment'].add(tx_obj)
	minator['currentBitCoin'] = minator['currentBitCoin'] - tx['output']

function update(address, tx):
	aggiornare i valori


function startParsing():

	for block in blocks:
		tx = newTX(block['tx'][0], block['time'])

		#I miner vengono creati solo per la tx0
		for address in tx['addresses_receving']:
			if minersAddresses.contains(address):
				update(address, tx)
			else:
				address_obj = new Address(address, tx)
				minersAddresses.append(address_obj)
			

		#Le altre transazioni aggiungo informazioni
		for tx in tx[1->len]:
			tx_obj = new TX(tx)
			
			minatorList = getAllMinerFromList(tx_obj[ 'addressesValue_sending'])  #filtrare la lista in python
			if ( minatorList.size > 0):
				for minator in minatorList:
					addNewPayment(minator, tx_obj)

			minatorList = getAllMinerFromList(tx_obj['addressesValue_receving']) #filtrare la lista in python
			if ( minatorList.size > 0):
				for minator in minatorList:
					addNewCredit(minator, tx_obj)


